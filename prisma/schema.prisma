// ShareIt Backend - Prisma Schema
// Peer-to-Peer Neighborhood Sharing Platform

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Category {
  tools
  outdoor_recreation
  party_events
  lawn_garden
  vehicles_transport
  workspace
  specialized_equipment
  services
  other
}

enum ListingType {
  item
  service
}

enum ItemCondition {
  new
  excellent
  good
  fair
  poor
}

enum PricingType {
  free
  hourly
  daily
  weekly
  monthly
}

enum ProtectionPreference {
  waiver_ok
  insurance_required
  deposit_required
  let_me_decide
}

enum RequestStatus {
  open
  matched
  accepted
  cancelled
  expired
}

enum MatchResponse {
  pending
  accepted
  declined
  ignored
}

enum TransactionStatus {
  requested
  accepted
  pickup_confirmed
  active
  return_initiated
  return_confirmed
  completed
  disputed
  cancelled
}

enum ProtectionType {
  waiver
  insurance
  deposit
}

enum PaymentStatus {
  pending
  authorized
  captured
  refunded
  partial_refund
}

enum PhotoType {
  pickup_full_view
  pickup_damage
  pickup_serial
  return_full_view
  return_damage
  return_serial
}

enum RatingRole {
  lender
  borrower
}

// ============================================================================
// MODELS
// ============================================================================

/// Users - Both lenders and borrowers (same user, different contexts)
model User {
  id              String   @id @default(uuid()) @db.Uuid
  email           String   @unique
  passwordHash    String   @map("password_hash")
  firstName       String   @map("first_name")
  middleName      String?  @map("middle_name")
  lastName        String   @map("last_name")
  phoneNumber     String?  @unique @map("phone_number")
  profilePhotoUrl String?  @map("profile_photo_url")
  address         String?  // Street address line 1
  address2        String?  @map("address_2") // Apt, Suite, etc.
  city            String?
  state           String?
  zipCode         String?  @map("zip_code")
  latitude        Decimal? @db.Decimal(10, 8)
  longitude       Decimal? @db.Decimal(11, 8)
  neighborhood    String?
  isVerified      Boolean  @default(false) @map("is_verified")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  items                   Item[]
  requests                Request[]
  borrowerTransactions    Transaction[]  @relation("BorrowerTransactions")
  lenderTransactions      Transaction[]  @relation("LenderTransactions")
  uploadedPhotos          Photo[]
  sentMessages            Message[]      @relation("SentMessages")
  receivedMessages        Message[]      @relation("ReceivedMessages")
  ratingsGiven            Rating[]       @relation("RatingsGiven")
  ratingsReceived         Rating[]       @relation("RatingsReceived")
  notificationPreferences NotificationPreference[]
  notifications           Notification[]

  @@index([latitude, longitude], name: "idx_user_location")
  @@index([neighborhood], name: "idx_user_neighborhood")
  @@map("users")
}

/// Items - Things users lend/rent (tools, equipment, services, workspace, vehicles, etc.)
model Item {
  id                   String               @id @default(uuid()) @db.Uuid
  ownerId              String               @map("owner_id") @db.Uuid

  // Legacy category field (kept for backward compatibility)
  category             Category
  subcategory          String?

  // New hierarchical category fields
  listingType          ListingType?         @map("listing_type")
  categoryTier1        String?              @map("category_tier1")
  categoryTier2        String?              @map("category_tier2")
  categoryTier3        String?              @map("category_tier3")
  isOther              Boolean              @default(false) @map("is_other")
  customItemName       String?              @map("custom_item_name")

  title                String
  description          String?              @db.Text
  condition            ItemCondition
  replacementValue     Decimal              @map("replacement_value") @db.Decimal(10, 2)
  pricingType          PricingType          @map("pricing_type")
  priceAmount          Decimal?             @map("price_amount") @db.Decimal(10, 2)
  lateFeeAmount        Decimal?             @map("late_fee_amount") @db.Decimal(10, 2)
  protectionPreference ProtectionPreference @map("protection_preference")
  depositPercentage    Int                  @default(0) @map("deposit_percentage")
  isAvailable          Boolean              @default(true) @map("is_available")
  availableFrom        DateTime?            @map("available_from")
  availableUntil       DateTime?            @map("available_until")
  photoUrls            Json                 @default("[]") @map("photo_urls")
  specialInstructions  String?              @map("special_instructions") @db.Text
  details              Json?                @default("{}") // Stores category-specific details like { "length": "180-195cm", "bootsIncluded": true }
  createdAt            DateTime             @default(now()) @map("created_at")
  updatedAt            DateTime             @updatedAt @map("updated_at")

  // Relations
  owner        User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  matches      Match[]
  transactions Transaction[]

  @@index([ownerId], name: "idx_item_owner")
  @@index([category], name: "idx_item_category")
  @@index([isAvailable], name: "idx_item_available")
  @@index([ownerId, isAvailable], name: "idx_item_owner_available")
  @@index([listingType, categoryTier1], name: "idx_item_type_tier1")
  @@index([listingType, categoryTier1, categoryTier2], name: "idx_item_type_tier1_tier2")
  @@map("items")
}

/// Requests - Borrower posts what they need (the core differentiator)
model Request {
  id              String        @id @default(uuid()) @db.Uuid
  requesterId     String        @map("requester_id") @db.Uuid

  // Legacy category field (kept for backward compatibility)
  category        Category

  // New hierarchical category fields
  listingType     ListingType?  @map("listing_type")
  categoryTier1   String?       @map("category_tier1")
  categoryTier2   String?       @map("category_tier2")
  categoryTier3   String?       @map("category_tier3")
  isOther         Boolean       @default(false) @map("is_other")
  customNeed      String?       @map("custom_need")

  title           String
  details         Json?         @default("{}") // Stores required/preferred specifications for the request
  description     String?       @db.Text
  neededFrom      DateTime      @map("needed_from")
  neededUntil     DateTime      @map("needed_until")
  maxBudget       Decimal?      @map("max_budget") @db.Decimal(10, 2)
  maxDistanceMiles Decimal      @default(10) @map("max_distance_miles") @db.Decimal(5, 2)
  latitude        Decimal       @db.Decimal(10, 8)
  longitude       Decimal       @db.Decimal(11, 8)
  status          RequestStatus @default(open)
  expiresAt       DateTime      @map("expires_at")
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")

  // Relations
  requester    User          @relation(fields: [requesterId], references: [id], onDelete: Cascade)
  matches      Match[]
  transactions Transaction[]

  @@index([requesterId], name: "idx_request_requester")
  @@index([status], name: "idx_request_status")
  @@index([category], name: "idx_request_category")
  @@index([expiresAt], name: "idx_request_expires")
  @@index([latitude, longitude, status], name: "idx_request_location_status")
  @@index([listingType, categoryTier1], name: "idx_request_type_tier1")
  @@index([listingType, categoryTier1, categoryTier2], name: "idx_request_type_tier1_tier2")
  @@map("requests")
}

/// Matches - Links requests to items that could fulfill them (many-to-many)
model Match {
  id              String        @id @default(uuid()) @db.Uuid
  requestId       String        @map("request_id") @db.Uuid
  itemId          String        @map("item_id") @db.Uuid
  distanceMiles   Decimal       @map("distance_miles") @db.Decimal(6, 2)
  matchScore      Decimal       @map("match_score") @db.Decimal(4, 1)
  lenderNotified  Boolean       @default(false) @map("lender_notified")
  lenderResponse  MatchResponse @default(pending) @map("lender_response")
  respondedAt     DateTime?     @map("responded_at")
  createdAt       DateTime      @default(now()) @map("created_at")

  // Relations
  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)
  item    Item    @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([requestId, itemId], name: "uq_match_request_item")
  @@index([requestId], name: "idx_match_request")
  @@index([itemId], name: "idx_match_item")
  @@index([lenderResponse], name: "idx_match_response")
  @@map("matches")
}

/// Transactions - The actual rental agreement between borrower and lender
model Transaction {
  id               String            @id @default(uuid()) @db.Uuid
  requestId        String?           @map("request_id") @db.Uuid
  itemId           String            @map("item_id") @db.Uuid
  borrowerId       String            @map("borrower_id") @db.Uuid
  lenderId         String            @map("lender_id") @db.Uuid
  status           TransactionStatus @default(requested)
  pickupTime       DateTime          @map("pickup_time")
  returnTime       DateTime          @map("return_time")
  actualPickupTime DateTime?         @map("actual_pickup_time")
  actualReturnTime DateTime?         @map("actual_return_time")
  rentalFee        Decimal           @map("rental_fee") @db.Decimal(10, 2)
  platformFee      Decimal           @map("platform_fee") @db.Decimal(10, 2)
  protectionType   ProtectionType    @map("protection_type")
  depositAmount    Decimal?          @map("deposit_amount") @db.Decimal(10, 2)
  insuranceFee     Decimal?          @map("insurance_fee") @db.Decimal(10, 2)
  taxRate          Decimal?          @map("tax_rate") @db.Decimal(5, 4)
  taxAmount        Decimal?          @map("tax_amount") @db.Decimal(10, 2)
  totalCharged     Decimal           @map("total_charged") @db.Decimal(10, 2)
  lateFeeCharged   Decimal?          @map("late_fee_charged") @db.Decimal(10, 2)
  paymentStatus    PaymentStatus     @default(pending) @map("payment_status")
  paymentIntentId  String?           @map("payment_intent_id")
  disputeReason    String?           @map("dispute_reason") @db.Text
  returnReminderSent Boolean         @default(false) @map("return_reminder_sent")
  overdueNotificationSent Boolean    @default(false) @map("overdue_notification_sent")
  createdAt        DateTime          @default(now()) @map("created_at")
  updatedAt        DateTime          @updatedAt @map("updated_at")

  // Relations
  request  Request?  @relation(fields: [requestId], references: [id], onDelete: SetNull)
  item     Item      @relation(fields: [itemId], references: [id], onDelete: Restrict)
  borrower User      @relation("BorrowerTransactions", fields: [borrowerId], references: [id], onDelete: Restrict)
  lender   User      @relation("LenderTransactions", fields: [lenderId], references: [id], onDelete: Restrict)
  photos   Photo[]
  messages Message[]
  ratings  Rating[]

  @@index([borrowerId], name: "idx_transaction_borrower")
  @@index([lenderId], name: "idx_transaction_lender")
  @@index([itemId], name: "idx_transaction_item")
  @@index([status], name: "idx_transaction_status")
  @@index([pickupTime], name: "idx_transaction_pickup")
  @@index([status, createdAt], name: "idx_transaction_status_created")
  @@index([borrowerId, status], name: "idx_transaction_borrower_status")
  @@index([lenderId, status], name: "idx_transaction_lender_status")
  @@map("transactions")
}

/// Photos - Metadata for pickup/return verification photos
model Photo {
  id            String    @id @default(uuid()) @db.Uuid
  transactionId String    @map("transaction_id") @db.Uuid
  uploadedBy    String    @map("uploaded_by") @db.Uuid
  photoType     PhotoType @map("photo_type")
  fileUrl       String    @map("file_url")
  metadata      Json      @default("{}") // GPS coordinates, timestamp, device info
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  uploader    User        @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)

  @@index([transactionId], name: "idx_photo_transaction")
  @@index([photoType], name: "idx_photo_type")
  @@map("photos")
}

/// Messages - Transaction-specific chat between borrower and lender
model Message {
  id            String   @id @default(uuid()) @db.Uuid
  transactionId String   @map("transaction_id") @db.Uuid
  senderId      String   @map("sender_id") @db.Uuid
  recipientId   String   @map("recipient_id") @db.Uuid
  messageText   String   @map("message_text") @db.Text
  photoUrl      String?  @map("photo_url")
  isRead        Boolean  @default(false) @map("is_read")
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  sender      User        @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  recipient   User        @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([transactionId], name: "idx_message_transaction")
  @@index([senderId], name: "idx_message_sender")
  @@index([recipientId], name: "idx_message_recipient")
  @@index([createdAt], name: "idx_message_created")
  @@map("messages")
}

/// Ratings - Dual ratings - both parties rate each other after transaction
model Rating {
  id                  String     @id @default(uuid()) @db.Uuid
  transactionId       String     @map("transaction_id") @db.Uuid
  raterId             String     @map("rater_id") @db.Uuid
  ratedUserId         String     @map("rated_user_id") @db.Uuid
  role                RatingRole // Context: was the rated user acting as lender or borrower
  overallRating       Int        @map("overall_rating") // 1-5 stars
  onTimeRating        Int?       @map("on_time_rating") // 1-5
  communicationRating Int?       @map("communication_rating") // 1-5
  conditionRating     Int?       @map("condition_rating") // 1-5, for borrowers
  itemAsDescribedRating Int?     @map("item_as_described_rating") // 1-5, for lenders
  reviewText          String?    @map("review_text") @db.Text
  wouldTransactAgain  Boolean    @map("would_transact_again")
  createdAt           DateTime   @default(now()) @map("created_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  rater       User        @relation("RatingsGiven", fields: [raterId], references: [id], onDelete: Cascade)
  ratedUser   User        @relation("RatingsReceived", fields: [ratedUserId], references: [id], onDelete: Cascade)

  @@unique([transactionId, raterId], name: "unique_rating_per_transaction_per_rater")
  @@index([transactionId], name: "idx_rating_transaction")
  @@index([ratedUserId], name: "idx_rating_rated_user")
  @@map("ratings")
}

/// Notification preferences per user per type
model NotificationPreference {
  id               String   @id @default(uuid()) @db.Uuid
  userId           String   @map("user_id") @db.Uuid
  notificationType String   @map("notification_type")
  inAppEnabled     Boolean  @default(true) @map("in_app_enabled")
  emailEnabled     Boolean  @default(true) @map("email_enabled")
  smsEnabled       Boolean  @default(false) @map("sms_enabled")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, notificationType], name: "unique_user_notification_type")
  @@index([userId], name: "idx_notification_pref_user")
  @@map("notification_preferences")
}

/// Notifications sent to users
model Notification {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @map("user_id") @db.Uuid
  type      String    // notification type
  title     String
  message   String
  data      Json?     // additional data (transactionId, itemId, etc.)
  isRead    Boolean   @default(false) @map("is_read")
  readAt    DateTime? @map("read_at")
  createdAt DateTime  @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead], name: "idx_notification_user_read")
  @@index([userId, createdAt], name: "idx_notification_user_created")
  @@map("notifications")
}
